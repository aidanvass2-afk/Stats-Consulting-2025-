library(dplyr)
library(zoo)

data_large=read.csv("C:\\Users\\alang\\OneDrive - University College Cork\\motor_policy_year_100k_2025-10-22.csv")
claims_data=read.csv("C:\\Users\\alang\\OneDrive - University College Cork\\motor_claims_100k_2025-10-22.csv")

# 0) START from your current data_large

# Count NAs BEFORE for both fields

before_na_emp <- sum(is.na(data_large$employment))

before_na_cc  <- sum(is.na(data_large$engine_cc))

# 1) Build imputed engine_cc from the CURRENT data_large

data_cc_imputed <- data_large %>%
  
  mutate(row_id = row_number(),
         
         birth_year = cal_year - vehicle_age) %>%
  
  arrange(policy_id, transmission, fuel, body_type, vehicle_power, birth_year, cal_year) %>%
  
  group_by(policy_id, transmission, fuel, body_type, vehicle_power, birth_year) %>%
  
  mutate(
    
    ok_linear_age  = ifelse(n() >= 2, all(diff(cal_year) == diff(vehicle_age)), TRUE),
    
    engine_cc_work = ifelse(ok_linear_age, engine_cc, NA_real_),
    
    engine_cc_work = zoo::na.locf(engine_cc_work, na.rm = FALSE),
    
    engine_cc_work = zoo::na.locf(engine_cc_work, fromLast = TRUE, na.rm = FALSE),
    
    engine_cc_final = ifelse(is.na(engine_cc) & ok_linear_age, engine_cc_work, engine_cc)
    
  ) %>%
  
  ungroup() %>%
  
  arrange(row_id)

# 2) WRITE BACK engine_cc and drop helpers

data_large <- data_cc_imputed %>%
  
  mutate(engine_cc = engine_cc_final) %>%
  
  select(-engine_cc_final, -engine_cc_work, -birth_year, -ok_linear_age, -row_id)

# 3) Now update EMPLOYMENT using OCCUPATION

data_large <- data_large %>%
  
  mutate(
    
    employment = case_when(
      
      is.na(employment) & !is.na(occupation) & occupation != "Unemployed" ~ "Employed",
      
      is.na(employment) & occupation == "Unemployed" ~ "Unemployed",
      
      TRUE ~ employment
      
    )
    
  )

# 4) Count NAs AFTER

after_na_cc  <- sum(is.na(data_large$engine_cc))

after_na_emp <- sum(is.na(data_large$employment))

cat("engine_cc NAs  | before:", before_na_cc,  " after:", after_na_cc,  "\n")

cat("employment NAs | before:", before_na_emp, " after:", after_na_emp, "\n")
#5)
policies_with_3 <- data_large %>%
  group_by(policy_id) %>%
  summarise(n_mileage_obs = sum(!is.na(reported_mileage)), .groups = "drop") %>%
  filter(n_mileage_obs == 3)

# How many such policies?
nrow(policies_with_3)

# Peek
head(policies_with_3)


# Compute policy means for those policies
means_3 <- data_large %>%
  semi_join(policies_with_3, by = "policy_id") %>%
  group_by(policy_id) %>%
  summarise(mean_mileage = mean(reported_mileage, na.rm = TRUE), .groups = "drop")

# Impute only for policies-with-3 and only on NA rows
data_large <- data_large %>%
  left_join(means_3, by = "policy_id") %>%
  mutate(
    reported_mileage_imp = ifelse(
      is.na(reported_mileage) & !is.na(mean_mileage), mean_mileage, reported_mileage
    )
  ) %>%
  select(-mean_mileage)

data_large <- data_large %>%
  left_join(means_3, by = "policy_id") %>%
  mutate(
    reported_mileage = ifelse(
      is.na(reported_mileage) & !is.na(mean_mileage),
      mean_mileage,
      reported_mileage
    )
  ) %>%
  select(-mean_mileage)
data_large <- data_large %>% select(-reported_mileage_imp)
# 6) Full missingness table (sanity)

missing_summary <- data_large %>%
  
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  
  tidyr::pivot_longer(everything(), names_to = "variable", values_to = "n_missing") %>%
  
  mutate(total_rows = nrow(data_large),
         
         pct_missing = round(100 * n_missing / total_rows, 2)) %>%
  
  arrange(desc(pct_missing))

print(missing_summary, n = 30)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
na_rows <- data_large %>%
  dplyr::filter(dplyr::if_any(c(reported_mileage, engine_cc), is.na))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# (Optional but recommended) Reduce policy to one row per key, preferring non-NA vehicle_power
# Change 'policy_id' to your real key(s).
policy_keyed <- data_large %>%
  arrange(is.na(vehicle_power)) %>%        # non-NA first
  distinct(policy_id, .keep_all = TRUE) %>%# 1 row per policy_id
  select(policy_id, vehicle_power)         # keep only what we need


# Join policy → claims and fill NAs in claims$vehicle_power
claims_fixed <- claims_data %>%
  left_join(policy_keyed, by = "policy_id", suffix = c("", "_from_policy")) %>%
  mutate(
    vehicle_power = coalesce(vehicle_power, vehicle_power_from_policy)
  ) %>%
  select(-vehicle_power_from_policy)


# Check results
before <- sum(is.na(claims_data$vehicle_power))
after  <- sum(is.na(claims_fixed$vehicle_power))
cat("NAs before:", before, " | NAs after:", after, "\n")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# If you already have `na_rows`, use this:
na_ids <- na_rows %>% distinct(policy_id)

# Otherwise, derive them directly from data_large:
# na_ids <- data_large %>%
#   filter(if_any(c(reported_mileage, engine_cc), is.na)) %>%
#   distinct(policy_id)

# Drop those policy_ids from both datasets
policies_clean <- data_large %>% anti_join(na_ids, by = "policy_id")
claims_clean   <- claims_fixed %>% anti_join(na_ids, by = "policy_id")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#sanity check
library(dplyr)
library(tidyr)

# Helper: NA summary per column
na_summary <- function(df) {
  df %>%
    summarise(across(everything(), ~sum(is.na(.)))) %>%
    pivot_longer(everything(), names_to = "column", values_to = "n_na") %>%
    mutate(n_total = nrow(df), pct_na = round(100 * n_na / n_total, 2)) %>%
    arrange(desc(n_na))
}

# Run for each dataset
(policies_na_summary <- na_summary(policies_clean))   # for data_large
(claims_na_summary   <- na_summary(claims_clean) ) # for claims_data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~###

## --- Setup ---------------------------------------------------------------
suppressPackageStartupMessages({
  library(dplyr)
})

# Fields we want to bring from policies into claims
add_fields <- c(
  "employment", "marital", "num_drivers", "occupation",
  "primary_usage", "reported_mileage", "vehicle_age", "years_licensed"
)

## --- Harmonise join keys (type mismatches can break joins) --------------
policies_clean <- policies_clean %>%
  mutate(policy_id = as.character(policy_id),
         cal_year  = as.integer(cal_year))

claims_clean <- claims_clean %>%
  mutate(policy_id = as.character(policy_id),
         cal_year  = as.integer(cal_year))

## --- Work out exactly which columns to add ------------------------------
have_in_policies <- intersect(add_fields, names(policies_clean))
need_to_add <- setdiff(have_in_policies, names(claims_clean))

if (length(need_to_add) == 0) {
  message("Nothing to add: none of the requested fields are available (or they're already in claims_clean).")
  claims_enriched <- claims_clean
} else {
  ## --- Deduplicate policies on (policy_id, cal_year) --------------------
  # If duplicates exist, we keep the first occurrence per key
  policies_for_join <- policies_clean %>%
    select(policy_id, cal_year, all_of(need_to_add)) %>%
    arrange(policy_id, cal_year) %>%
    distinct(policy_id, cal_year, .keep_all = TRUE)
  
  dup_n <- policies_clean %>%
    count(policy_id, cal_year, name = "n") %>%
    filter(n > 1) %>% nrow()
  if (dup_n > 0) {
    message("Note: found ", dup_n, " duplicated (policy_id, cal_year) keys in policies_clean; using the first per key.")
  }
  
  ## --- Join onto claims --------------------------------------------------
  claims_enriched <- claims_clean %>%
    left_join(policies_for_join, by = c("policy_id", "cal_year"))
  
  ## --- Quick diagnostics -------------------------------------------------
  match_diag <- claims_clean %>%
    distinct(policy_id, cal_year) %>%
    left_join(policies_for_join %>% mutate(.has_match = TRUE) %>%
                select(policy_id, cal_year, .has_match),
              by = c("policy_id","cal_year")) %>%
    summarise(
      n_claim_keys = n(),
      n_matched    = sum(!is.na(.has_match)),
      match_rate   = n_matched / n_claim_keys
    )
  print(match_diag)
}

## ============================================================
## 0) Severity inflation factors (calendar-year based)
##    Rates chosen for *claim severity*, not frequency or CPI.
##    These are annual % increases in average claim size.
## ============================================================

# Named vector: severity inflation by calendar year
# (rough, judgemental, but anchored to NCID & CPI evidence)
severity_inflation <- c(
  "2016" = 0.02,  # 2%
  "2017" = 0.02,  # 2%
  "2018" = 0.03,  # 3%
  "2019" = 0.03,  # 3%
  "2020" = 0.00,  # 0% (COVID year, suppressed activity)
  "2021" = 0.03,  # 3%
  "2022" = 0.08,  # 8% (big repair cost shock)
  "2023" = 0.05,  # 5%
  "2024" = 0.03,  # 3%
  "2025" = 0.02   # 2% forward-looking for uplift from 2024 → 2025
)

## ============================================================
## 1) Sanity checks
## ============================================================

# Make sure required columns exist
stopifnot("cal_year" %in% names(claims_enriched))
stopifnot("gross_amount" %in% names(claims_enriched))

# Check that all cal_years are within the range we have factors for
years_in_data <- sort(unique(claims_enriched$cal_year))
years_missing <- years_in_data[!years_in_data %in% as.integer(names(severity_inflation))]

if (length(years_missing) > 0) {
  stop(
    "No severity inflation factor defined for cal_year(s): ",
    paste(years_missing, collapse = ", ")
  )
}

## ============================================================
## 2) Function to get factor to 2025 terms
## ============================================================

# For a claim in year Y, we multiply by the product of (1 + inflation)
# for years Y+1, Y+2, ..., 2025.
# Example: a 2019 claim gets factors for 2020–2025.
inflation_factor_to_2025 <- function(year) {
  future_years <- seq(year + 1L, 2025L)
  
  if (length(future_years) == 0) {
    return(1)  # already 2025 (no uplift)
  }
  
  fy_char <- as.character(future_years)
  prod(1 + severity_inflation[fy_char])
}

# Vectorised version over a vector of years
inflation_factor_to_2025_vec <- function(year_vec) {
  sapply(year_vec, inflation_factor_to_2025)
}

## ============================================================
## 3) Apply to claims_enriched
## ============================================================

claims_enriched <- claims_enriched %>%
  mutate(
    infl_factor_2025   = inflation_factor_to_2025_vec(cal_year),
    gross_amount_2025  = gross_amount * infl_factor_2025
  )

# Optional: quick check
summary(claims_enriched$gross_amount)
summary(claims_enriched$gross_amount_2025)

# Use `claims_enriched` downstream.


## claims_enriched and policies_cleaned are the correct data sets
